# Copilot Instructions for AspireKeyCloakTemplate

This file contains instructions for GitHub Copilot to help it understand this codebase and generate better code suggestions.

## Repository Overview

This is an opinionated .NET 10 + React template integrating:
- **Aspire** for cloud-ready patterns and orchestration
- **Keycloak** for authentication (OIDC)
- **YARP** as a gateway/reverse-proxy and Backend-for-Frontend (BFF)
- **Vite + React** for the frontend (Node.js 22.12.0+)
- Custom **Mediator pattern** implementation for CQRS-style request handling

## Project Structure and Responsibilities

### src/AspireKeyCloakTemplate.API
**Purpose**: Backend REST API implementing application functionality.
- Controllers, DTOs, domain/service layer
- Business rules and authorization policies
- JWT validation for Keycloak-issued tokens
- Should be agnostic to Gateway concerns
- Uses SharedKernel for common DI and configuration

### src/AspireKeyCloakTemplate.BFF (Gateway)
**Purpose**: Edge reverse-proxy using YARP that acts as a Backend-for-Frontend.
- Routes client traffic to downstream services (API)
- Handles authentication at the edge (OIDC with Keycloak)
- Server-side token storage and refresh (keeps secrets out of browser)
- Anti-forgery token management (CSRF protection)
- Aggregates downstream calls for SPA-friendly responses
- For implementation details, see `docs/BFF.md`

### src/AspireKeyCloakTemplate.SharedKernel
**Purpose**: Shared defaults, extensions, and patterns used across projects.
- Custom Mediator pattern implementation (similar to MediatR)
- Caching behaviors with `IDistributedCache`
- Validation behaviors using FluentValidation
- Common DI extensions and configuration
- OpenTelemetry and logging setup
- See `MEDIATOR_QUICK_START.md` for mediator usage

### src/AppHost
**Purpose**: Aspire composite host for local development and integration scenarios.
- Orchestrates API, BFF, and frontend components
- Configures service discovery and dependencies

### src/react-app
**Purpose**: Vite + React SPA with Keycloak authentication.
- OIDC client setup and token management
- API calls through the Gateway/BFF
- TanStack Router for routing
- TanStack Query for data fetching
- Biome for linting and formatting

### Test Projects
- **AspireKeyCloakTemplate.BFF.UnitTests**: Fast unit tests with xUnit, Shouldly, NSubstitute
- **AspireKeyCloakTemplate.SharedKernel.UnitTests**: Tests for mediator and caching behaviors
- **AspireKeyCloakTemplate.IntegrationTests**: E2E tests with Playwright and Aspire.Hosting.Testing

## Building and Testing

### .NET Projects
```bash
# Build entire solution
dotnet build

# Run all tests
dotnet test

# Run specific test project
dotnet test src/AspireKeyCloakTemplate.BFF.UnitTests/AspireKeyCloakTemplate.BFF.UnitTests.csproj
```

### React Frontend
```bash
cd src/react-app

# Install dependencies
npm install

# Development server (port 3000)
npm run dev

# Production build
npm run build

# Run tests
npm run test

# Lint/format
npm run lint
npm run format
npm run check
```

### Integration Tests
Playwright browsers may need installation:
```bash
npx playwright install
```

## Coding Conventions

### C# (.NET)
- **Target**: `net10.0`
- **Indentation**: 4 spaces
- **Line endings**: CRLF
- **Nullable**: Enabled (`<Nullable>enable</Nullable>`)
- **Implicit usings**: Enabled
- **Warnings as errors**: Enabled in SharedKernel
- **Async/await**: Use async methods consistently; suffix with `Async` convention
- **File-scoped namespaces**: Use file-scoped namespace declarations where possible
- **Primary constructors**: Use for dependency injection in classes with minimal logic
- **XML comments**: Use `///` for public APIs and complex logic

### Naming Conventions (.NET)
- **Classes/Interfaces**: PascalCase (e.g., `IRequestHandler`, `GetCurrentUserQuery`)
- **Methods**: PascalCase (e.g., `Handle`, `SendAsync`)
- **Private fields**: `_camelCase` with underscore prefix
- **Properties**: PascalCase
- **Local variables**: camelCase
- **Constants**: PascalCase
- **Records**: Use for DTOs, queries, commands (e.g., `record GetUserQuery(string Id)`)
- **Endpoints**: `{Verb}{Entity}Endpoint` (e.g., `GetCurrentUserEndpoint`)
- **Handlers**: `{Request}Handler` (e.g., `GetCurrentUserQueryHandler`)
- **Validators**: `{Request}Validator` (e.g., `GetCurrentUserQueryValidator`)

### TypeScript/React
- **Indentation**: 2 spaces (enforced by Biome)
- **Line endings**: LF
- **Quotes**: Double quotes (Biome setting)
- **Components**: PascalCase for component names
- **Files**: kebab-case for file names, PascalCase for component files
- **Hooks**: Use `use` prefix (e.g., `useAuth`, `useFetch`)
- **Types/Interfaces**: PascalCase, prefer `type` over `interface` unless extending
- **Constants**: UPPER_SNAKE_CASE for true constants, camelCase for config objects

### Folder Structure Conventions
**.NET Projects**:
- Organize by feature: `Features/{FeatureName}/{Queries|Commands|Endpoints}/`
- Example: `Features/Users/Queries/GetCurrentUser/GetCurrentUserQuery.cs`
- Keep related files together (query, handler, validator, tests)

**React**:
- `src/features/{feature-name}/` for feature-specific code
- `src/components/` for shared components
- `src/hooks/` for custom hooks
- `src/lib/` for utilities

## Mediator Pattern (Custom Implementation)

This codebase uses a custom Mediator pattern implementation in `SharedKernel`. It is NOT MediatR.

### Registration
```csharp
using AspireKeyCloakTemplate.SharedKernel.Features.Mediator;

builder.Services.AddMediator(Assembly.GetExecutingAssembly());
```

### Creating Requests
```csharp
// Query (read operation)
public record GetSomethingQuery(string Id) : IRequest<SomethingDto>;

// Command (write operation)
public record CreateSomethingCommand(string Name) : IRequest<string>;
```

### Creating Handlers
```csharp
public class GetSomethingQueryHandler : IRequestHandler<GetSomethingQuery, SomethingDto>
{
    public async Task<SomethingDto> Handle(GetSomethingQuery request, CancellationToken cancellationToken)
    {
        // Handler logic
    }
}
```

### Using in Endpoints
```csharp
builder.MapGet("/something/{id}", async (string id, IMediator mediator) =>
{
    var result = await mediator.Send(new GetSomethingQuery(id));
    return Results.Ok(result);
});
```

For complete guide, see `MEDIATOR_QUICK_START.md`.

## Validation

Use **FluentValidation** for request validation in .NET:

```csharp
public class GetSomethingQueryValidator : AbstractValidator<GetSomethingQuery>
{
    public GetSomethingQueryValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty()
            .WithMessage("Id is required");
    }
}
```

Validators are automatically discovered and run through the `ValidationBehavior` pipeline.

## Caching

### IDistributedCache
Use `IDistributedCache` for caching in .NET (supports Redis for production):

```csharp
// Caching is built into the mediator pipeline via CachingBehavior
// Implement ICacheableRequest on your request:
public record GetSomethingQuery(string Id) : IRequest<SomethingDto>, ICacheableRequest
{
    public string CacheKey => $"something-{Id}";
    public TimeSpan? CacheExpiration => TimeSpan.FromMinutes(5);
}
```

### Cache Invalidation
Use notifications for cache invalidation:
```csharp
// Invalidate specific cache key
await mediator.Publish(new CacheInvalidationNotification("something-123"));

// Invalidate cache group
await mediator.Publish(new CacheGroupInvalidationNotification("something-*"));
```

## Testing Practices

### .NET Unit Tests
- **Framework**: xUnit
- **Assertions**: Shouldly (fluent assertions)
- **Mocking**: NSubstitute
- **Naming**: `{MethodName}_{Scenario}_Should{ExpectedBehavior}`

Example:
```csharp
[Fact]
public async Task Handle_ValidRequest_ShouldReturnUser()
{
    // Arrange
    var handler = new GetUserHandler();
    
    // Act
    var result = await handler.Handle(new GetUserQuery("123"), CancellationToken.None);
    
    // Assert
    result.ShouldNotBeNull();
    result.Id.ShouldBe("123");
}
```

### React Tests
- **Framework**: Vitest
- **Testing Library**: @testing-library/react
- **Naming**: Describe blocks with `it()` for test cases

Example:
```typescript
describe("fetchAndStoreXsrfToken", () => {
    it("should fetch the XSRF token and update the store on success", async () => {
        // Arrange, Act, Assert
    });
});
```

### Integration Tests
- **Framework**: Playwright with Aspire.Hosting.Testing
- **Browser**: Chromium (auto-installed via Playwright)
- Inherit from `PlaywrightTestBase` for E2E tests
- Tests run against the full Aspire application stack

## Error Handling and Logging

### Exception Handling
- Use specific exception types rather than generic `Exception`
- Catch and handle exceptions at appropriate layers
- Log exceptions with structured logging

### Logging
Use structured logging with `ILogger<T>`:
```csharp
// Prefer log source generators (compile-time)
[LoggerMessage(LogLevel.Information, "Processing request for {UserId}")]
static partial void LogProcessingRequest(ILogger logger, string userId);

// Use in handler
LogProcessingRequest(_logger, request.UserId);
```

### Validation Errors
FluentValidation errors are automatically returned as structured problem details.

## Security Considerations

### Authentication & Authorization
- API validates JWT tokens from Keycloak
- BFF handles OIDC flows and stores tokens server-side
- Use HttpOnly, Secure, SameSite cookies for session management
- Never expose tokens to JavaScript in the browser

### CSRF Protection
- BFF uses anti-forgery tokens for state-changing operations
- Tokens are managed via YARP transforms:
  - `AddAntiforgeryTokenResponseTransform`: Adds token to HTML responses
  - `ValidateAntiforgeryTokenRequestTransform`: Validates token on requests

### Input Validation
- Always validate user input with FluentValidation
- Use parameterized queries to prevent SQL injection
- Sanitize output when rendering user content

### HTTPS
- Use HTTPS in production
- `RequireHttpsMetadata` disabled only for local development

## Common Patterns

### Dependency Injection
- Register services in `Program.cs` or extension methods
- Use constructor injection (primary constructors preferred)
- Use `IOptions<T>` for configuration

### Configuration
- Store config in `appsettings.json`
- Use secrets manager for sensitive data in production
- Environment-specific configs: `appsettings.Development.json`

### OpenTelemetry
- Tracing, metrics, and logs are configured in SharedKernel
- Use `Activity` for custom spans when needed

## Common Tasks

### Adding a New API Endpoint
1. Create query/command in `Features/{Feature}/Queries|Commands/{Name}/`
2. Create handler implementing `IRequestHandler<TRequest, TResponse>`
3. Add validator if needed (optional)
4. Create endpoint class implementing `IEndpoint`
5. Write unit tests for handler
6. Write integration tests for endpoint

### Adding Frontend Features
1. Create feature folder in `src/features/{feature-name}/`
2. Add components, hooks, and API clients
3. Use TanStack Query for data fetching
4. Use TanStack Router for routing
5. Write Vitest tests for logic

### Updating Dependencies
- .NET: Update versions in `Directory.Packages.props` (centralized package management)
- React: Update in `src/react-app/package.json`

## References
- Architecture: `README.md`
- BFF Design: `docs/BFF.md`
- Mediator Guide: `MEDIATOR_QUICK_START.md`
- Mediator Implementation: `src/AspireKeyCloakTemplate.SharedKernel/Features/Mediator/README.md`

## Tips for Copilot
- When creating new handlers, follow the mediator pattern consistently
- Always add validators for user-facing requests
- Use Shouldly for all test assertions
- Use NSubstitute for mocking dependencies
- Follow existing patterns in similar features
- Keep BFF logic focused on orchestration, not business rules
- Business logic belongs in the API, not the BFF
- Use distributed caching with `IDistributedCache` for scalable caching
- Follow the feature folder structure for consistency
